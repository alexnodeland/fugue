<!DOCTYPE HTML>
<html lang="en" class="dark sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Home - Fugue Docs</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./mdbook-admonish.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "dark";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('dark')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Fugue Docs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/alexnodeland/fugue" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="fugue"><a class="header" href="#fugue">Fugue</a></h1>
<p><a href="https://crates.io/crates/fugue"><img src="https://img.shields.io/crates/v/fugue.svg" alt="Crates.io" /></a>
<a href="https://docs.rs/fugue"><img src="https://docs.rs/fugue/badge.svg" alt="Documentation" /></a>
<a href="https://opensource.org/licenses/MIT"><img src="https://img.shields.io/badge/License-MIT-yellow.svg" alt="License: MIT" /></a>
<a href="https://codecov.io/gh/alexnodeland/fugue"><img src="https://codecov.io/gh/alexnodeland/fugue/graph/badge.svg?token=BDJ5OB6GOB" alt="codecov" /></a>
<a href="https://www.rust-lang.org"><img src="https://img.shields.io/badge/rust-1.70%2B-blue.svg" alt="Rust" /></a></p>
<p>A <strong>production-ready</strong>, <strong>monadic probabilistic programming library</strong> for Rust. Write elegant probabilistic programs by composing <code>Model</code> values in direct style; execute them with pluggable interpreters and state-of-the-art inference algorithms.</p>
<h2 id="-features"><a class="header" href="#-features">✨ Features</a></h2>
<ul>
<li>🎯 <strong>Monadic PPL</strong>: Compose probabilistic programs using pure functional abstractions</li>
<li>🔢 <strong>Type-Safe Distributions</strong>: 10+ built-in probability distributions with natural return types</li>
<li>🎰 <strong>Multiple Inference Methods</strong>: MCMC, SMC, Variational Inference, ABC</li>
<li>📊 <strong>Comprehensive Diagnostics</strong>: R-hat convergence, effective sample size, Geweke tests</li>
<li>🛡️ <strong>Numerically Stable</strong>: Production-ready numerical algorithms with validation</li>
<li>🚀 <strong>Memory Optimized</strong>: Efficient trace handling and memory management</li>
<li>🎛️ <strong>Ergonomic Macros</strong>: Do-notation (<code>prob!</code>), vectorization (<code>plate!</code>), addressing (<code>addr!</code>)</li>
<li>⚡ <strong>High Performance</strong>: Zero-cost abstractions with pluggable runtime interpreters</li>
</ul>
<h2 id="-quick-start"><a class="header" href="#-quick-start">🚀 Quick Start</a></h2>
<p>Add Fugue to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
fugue = "0.3.0"
</code></pre>
<h3 id="simple-bayesian-linear-regression"><a class="header" href="#simple-bayesian-linear-regression">Simple Bayesian Linear Regression</a></h3>
<pre><pre class="playground"><code class="language-rust">use fugue::*;
use rand::rngs::StdRng;
use rand::SeedableRng;

fn bayesian_regression(x_data: &amp;[f64], y_data: &amp;[f64]) -&gt; Model&lt;(f64, f64)&gt; {
    let x_vec = x_data.to_vec(); // Clone to avoid lifetime issues in doctest
    let y_vec = y_data.to_vec(); // Clone to avoid lifetime issues in doctest
    
    prob! {
        // Priors - using safe constructors
        let slope &lt;- sample(addr!("slope"), Normal::new(0.0, 1.0).unwrap());
        let intercept &lt;- sample(addr!("intercept"), Normal::new(0.0, 1.0).unwrap());
        let noise &lt;- sample(addr!("noise"), LogNormal::new(0.0, 0.5).unwrap());

        // Likelihood - handle observations sequentially  
        let _observations &lt;- sequence_vec(x_vec.iter().zip(y_vec.iter()).enumerate().map(|(i, (&amp;x, &amp;y))| {
            let y_pred = slope * x + intercept;
            // Ensure noise is positive for Normal distribution
            let safe_noise = noise.abs().max(1e-6);
            observe(addr!("y", i), Normal::new(y_pred, safe_noise).unwrap(), y)
        }).collect());

        pure((slope, intercept))
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let x_data = vec![1.0, 2.0, 3.0, 4.0, 5.0];
    let y_data = vec![2.1, 3.9, 6.1, 8.0, 9.9];

    let mut rng = StdRng::seed_from_u64(42);

    // Run adaptive MCMC
    let samples = adaptive_mcmc_chain(
        &amp;mut rng,
        || bayesian_regression(&amp;x_data, &amp;y_data),
        1000,  // samples
        500,   // warmup
    );

    // Extract results using type-safe accessors
    let slopes: Vec&lt;f64&gt; = samples.iter()
        .filter_map(|(_, trace)| trace.get_f64(&amp;addr!("slope")))
        .collect();

    let mean_slope = slopes.iter().sum::&lt;f64&gt;() / slopes.len() as f64;
    println!("Estimated slope: {:.3}", mean_slope);

    // Diagnostics
    let ess = effective_sample_size_mcmc(&amp;slopes);
    println!("Effective sample size: {:.1}", ess);

    Ok(())
}</code></pre></pre>
<h2 id="-type-safety-revolution"><a class="header" href="#-type-safety-revolution">🎯 Type Safety Revolution</a></h2>
<p>Fugue features a <strong>fully type-safe distribution system</strong> that eliminates common probabilistic programming pitfalls:</p>
<h3 id="before-error-prone"><a class="header" href="#before-error-prone">Before (Error-Prone)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use fugue::*;
</span>let _example = sample(addr!("coin"), Bernoulli::new(0.5).unwrap())
    .bind(|coin_result| {
        // ❌ This would be error-prone if this returned f64 instead of bool
        // But Fugue returns bool, so coin_result is naturally a boolean
        if coin_result {
            pure("heads")
        } else {
            pure("tails")
        }
    });
<span class="boring">}</span></code></pre></pre>
<h3 id="after-type-safe"><a class="header" href="#after-type-safe">After (Type-Safe)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use fugue::*;
</span>let _example = sample(addr!("coin"), Bernoulli::new(0.5).unwrap())
    .bind(|is_heads| {
        // ✅ Natural: direct boolean usage, compiler-enforced
        if is_heads {
            pure("heads")
        } else {
            pure("tails")
        }
    });
<span class="boring">}</span></code></pre></pre>
<h3 id="-key-improvements"><a class="header" href="#-key-improvements">🔥 Key Improvements</a></h3>
<ul>
<li><strong>Bernoulli</strong> → <code>bool</code> (no more <code>== 1.0</code> comparisons)</li>
<li><strong>Poisson/Binomial</strong> → <code>u64</code> (natural counting, no casting)</li>
<li><strong>Categorical</strong> → <code>usize</code> (safe array indexing)</li>
<li><strong>Compiler guarantees</strong> type correctness throughout</li>
</ul>
<h2 id="-core-concepts"><a class="header" href="#-core-concepts">📚 Core Concepts</a></h2>
<h3 id="models-as-first-class-values"><a class="header" href="#models-as-first-class-values">Models as First-Class Values</a></h3>
<p>Fugue represents probabilistic programs as <code>Model&lt;A&gt;</code> values that can be composed, transformed, and reused:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use fugue::*;

// Pure deterministic computation
let model1 = pure(42.0);

// Type-safe probabilistic sampling with safe constructors
let normal_sample: Model&lt;f64&gt; = sample(addr!("x"), Normal::new(0.0, 1.0).unwrap());
let coin_flip: Model&lt;bool&gt; = sample(addr!("coin"), Bernoulli::new(0.5).unwrap());
let event_count: Model&lt;u64&gt; = sample(addr!("count"), Poisson::new(3.0).unwrap());
let category_choice: Model&lt;usize&gt; = sample(addr!("choice"), Categorical::new(
    vec![0.3, 0.5, 0.2]
).unwrap());

// Type-safe observations
let obs1 = observe(addr!("y"), Normal::new(0.0, 1.0).unwrap(), 2.5);       // f64
let obs2 = observe(addr!("success"), Bernoulli::new(0.7).unwrap(), true);   // bool
let obs3 = observe(addr!("events"), Poisson::new(4.0).unwrap(), 7u64);      // u64
let obs4 = observe(addr!("pick"), Categorical::new(vec![0.4, 0.6]).unwrap(), 1usize); // usize

// Monadic composition with type safety
let composed = coin_flip.bind(|is_heads| {
    if is_heads {
        sample(addr!("bonus"), Poisson::new(5.0).unwrap())
            .map(|count| format!("Heads! Bonus: {}", count))
    } else {
        pure("Tails!".to_string())
    }
});
<span class="boring">}</span></code></pre></pre>
<h3 id="do-notation-with-prob"><a class="header" href="#do-notation-with-prob">Do-Notation with <code>prob!</code></a></h3>
<p>Write probabilistic programs in an imperative style:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use fugue::*;
</span>let observed_value = 1.5; // Example observed value
let mixture_model = prob! {
    let z &lt;- sample(addr!("component"), Bernoulli::new(0.3).unwrap());  // Returns bool!
    let mu = if z { -2.0 } else { 2.0 };  // Natural boolean usage
    let x &lt;- sample(addr!("x"), Normal::new(mu, 1.0).unwrap());
    observe(addr!("y"), Normal::new(x, 0.1).unwrap(), observed_value);
    pure(x)
};
<span class="boring">}</span></code></pre></pre>
<h3 id="vectorized-operations-with-plate"><a class="header" href="#vectorized-operations-with-plate">Vectorized Operations with <code>plate!</code></a></h3>
<p>Efficiently handle collections of random variables:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use fugue::*;
</span>// Generate 100 independent samples
let samples = plate!(i in 0..100 =&gt; {
    sample(addr!("x", i), Normal::new(0.0, 1.0).unwrap())
});

// Hierarchical model with shared parameters
let hierarchical = prob! {
    let global_mu &lt;- sample(addr!("global_mu"), Normal::new(0.0, 1.0).unwrap());
    let local_effects &lt;- plate!(i in 0..10 =&gt; {
        sample(addr!("local", i), Normal::new(global_mu, 0.1).unwrap())
    });
    pure((global_mu, local_effects))
};
<span class="boring">}</span></code></pre></pre>
<h2 id="-inference-methods"><a class="header" href="#-inference-methods">🎯 Inference Methods</a></h2>
<h3 id="markov-chain-monte-carlo-mcmc"><a class="header" href="#markov-chain-monte-carlo-mcmc">Markov Chain Monte Carlo (MCMC)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use fugue::*;
</span><span class="boring">use rand::rngs::StdRng;
</span><span class="boring">use rand::SeedableRng;
</span><span class="boring">fn your_model() -&gt; Model&lt;f64&gt; { sample(addr!("x"), Normal::new(0.0, 1.0).unwrap()) }
</span><span class="boring">let mut rng = StdRng::seed_from_u64(42);
</span><span class="boring">let n_samples = 1000;
</span><span class="boring">let n_warmup = 500;
</span>// Adaptive Metropolis-Hastings with convergence diagnostics
let samples = adaptive_mcmc_chain(
    &amp;mut rng,
    || your_model(),
    n_samples,
    n_warmup,
);

// Extract parameter values for diagnostics
let parameter_values: Vec&lt;f64&gt; = samples.iter()
    .filter_map(|(_, trace)| trace.get_f64(&amp;addr!("x")))
    .collect();
    
// Compute R-hat for convergence diagnostics (simplified example)
println!("Collected {} samples", parameter_values.len());
<span class="boring">}</span></code></pre></pre>
<h3 id="sequential-monte-carlo-smc"><a class="header" href="#sequential-monte-carlo-smc">Sequential Monte Carlo (SMC)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use fugue::*;
</span><span class="boring">use rand::rngs::StdRng;
</span><span class="boring">use rand::SeedableRng;
</span><span class="boring">fn your_model() -&gt; Model&lt;f64&gt; { sample(addr!("x"), Normal::new(0.0, 1.0).unwrap()) }
</span><span class="boring">let mut rng = StdRng::seed_from_u64(42);
</span>let config = SMCConfig {
    resampling_method: ResamplingMethod::Systematic,
    ess_threshold: 0.5,
    rejuvenation_steps: 5,
};

let particles = adaptive_smc(&amp;mut rng, 1000, || your_model(), config);
let ess = effective_sample_size(&amp;particles);
<span class="boring">}</span></code></pre></pre>
<h3 id="variational-inference-vi"><a class="header" href="#variational-inference-vi">Variational Inference (VI)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use fugue::*;
</span><span class="boring">use rand::rngs::StdRng;
</span><span class="boring">use rand::SeedableRng;
</span><span class="boring">use std::collections::HashMap;
</span><span class="boring">fn your_model() -&gt; Model&lt;f64&gt; { sample(addr!("mu"), Normal::new(0.0, 1.0).unwrap()) }
</span><span class="boring">let mut rng = StdRng::seed_from_u64(42);
</span>// Mean-field variational approximation
let mut guide = MeanFieldGuide {
    params: HashMap::new()
};
guide.params.insert(addr!("mu"), VariationalParam::Normal { mu: 0.0, log_sigma: 0.0 });

let optimized_guide = optimize_meanfield_vi(
    &amp;mut rng,
    || your_model(),
    guide,
    1000,  // max iterations
    100,   // samples per iteration
    0.01,  // learning rate
);
<span class="boring">}</span></code></pre></pre>
<h3 id="approximate-bayesian-computation-abc"><a class="header" href="#approximate-bayesian-computation-abc">Approximate Bayesian Computation (ABC)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use fugue::*;
</span><span class="boring">use rand::rngs::StdRng;
</span><span class="boring">use rand::SeedableRng;
</span><span class="boring">fn your_model() -&gt; Model&lt;f64&gt; { sample(addr!("x"), Normal::new(0.0, 1.0).unwrap()) }
</span><span class="boring">let mut rng = StdRng::seed_from_u64(42);
</span><span class="boring">let simulator_fn = |trace: &amp;Trace| vec![trace.get_f64(&amp;addr!("x")).unwrap_or(0.0)];
</span><span class="boring">let observed_data = vec![2.0];
</span><span class="boring">let distance_fn = &amp;EuclideanDistance;
</span><span class="boring">let tolerance = 0.1;
</span><span class="boring">let max_samples = 1000;
</span>// Likelihood-free inference
let samples = abc_rejection(
    &amp;mut rng,
    || your_model(),
    simulator_fn,
    &amp;observed_data,
    distance_fn,
    tolerance,
    max_samples,
);
<span class="boring">}</span></code></pre></pre>
<h2 id="-built-in-distributions"><a class="header" href="#-built-in-distributions">📊 Built-in Distributions</a></h2>
<div class="table-wrapper"><table><thead><tr><th><strong>Distribution</strong></th><th><strong>Parameters</strong></th><th><strong>Return Type</strong></th><th><strong>Support</strong></th><th><strong>Usage</strong></th></tr></thead><tbody>
<tr><td><code>Normal</code></td><td><code>mu</code>, <code>sigma</code></td><td><code>f64</code></td><td>ℝ</td><td><code>Normal::new(0.0, 1.0).unwrap()</code></td></tr>
<tr><td><code>LogNormal</code></td><td><code>mu</code>, <code>sigma</code></td><td><code>f64</code></td><td>ℝ⁺</td><td><code>LogNormal::new(0.0, 1.0).unwrap()</code></td></tr>
<tr><td><code>Uniform</code></td><td><code>low</code>, <code>high</code></td><td><code>f64</code></td><td>[low, high]</td><td><code>Uniform::new(0.0, 1.0).unwrap()</code></td></tr>
<tr><td><code>Exponential</code></td><td><code>rate</code></td><td><code>f64</code></td><td>ℝ⁺</td><td><code>Exponential::new(1.0).unwrap()</code></td></tr>
<tr><td><code>Beta</code></td><td><code>alpha</code>, <code>beta</code></td><td><code>f64</code></td><td>[0, 1]</td><td><code>Beta::new(2.0, 3.0).unwrap()</code></td></tr>
<tr><td><code>Gamma</code></td><td><code>shape</code>, <code>rate</code></td><td><code>f64</code></td><td>ℝ⁺</td><td><code>Gamma::new(2.0, 1.0).unwrap()</code></td></tr>
<tr><td><code>Bernoulli</code></td><td><code>p</code></td><td><strong><code>bool</code></strong></td><td>{false, true}</td><td><code>Bernoulli::new(0.3).unwrap()</code></td></tr>
<tr><td><code>Binomial</code></td><td><code>n</code>, <code>p</code></td><td><strong><code>u64</code></strong></td><td>{0, 1, ..., n}</td><td><code>Binomial::new(10, 0.5).unwrap()</code></td></tr>
<tr><td><code>Categorical</code></td><td><code>probs</code></td><td><strong><code>usize</code></strong></td><td>{0, 1, ..., k-1}</td><td><code>Categorical::new(vec![0.2, 0.3, 0.5]).unwrap()</code></td></tr>
<tr><td><code>Poisson</code></td><td><code>lambda</code></td><td><strong><code>u64</code></strong></td><td>ℕ</td><td><code>Poisson::new(2.0).unwrap()</code></td></tr>
</tbody></table>
</div>
<h3 id="-type-safety-benefits"><a class="header" href="#-type-safety-benefits">🎯 Type Safety Benefits</a></h3>
<ul>
<li><strong><code>Bernoulli</code></strong> returns <code>bool</code> - no more <code>if sample == 1.0</code> comparisons!</li>
<li><strong><code>Poisson</code>/<code>Binomial</code></strong> return <code>u64</code> - natural counting with no casting needed</li>
<li><strong><code>Categorical</code></strong> returns <code>usize</code> - safe array indexing without conversion</li>
<li><strong>Continuous distributions</strong> return <code>f64</code> as appropriate</li>
<li><strong>Compiler guarantees</strong> - type errors caught at compile time</li>
</ul>
<p>All distributions include automatic parameter validation and numerical stability checks.</p>
<h2 id="-advanced-features"><a class="header" href="#-advanced-features">🛠️ Advanced Features</a></h2>
<h3 id="custom-interpreters"><a class="header" href="#custom-interpreters">Custom Interpreters</a></h3>
<p>Implement your own model interpreters with full type safety:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use fugue::*;
</span><span class="boring">use rand::Rng;
</span>struct CustomHandler&lt;R: Rng&gt; {
    rng: R,
    // Your state here
}

impl&lt;R: Rng&gt; Handler for CustomHandler&lt;R&gt; {
    fn on_sample_f64(&amp;mut self, addr: &amp;Address, dist: &amp;dyn Distribution&lt;f64&gt;) -&gt; f64 {
        // Handle continuous distributions
        dist.sample(&amp;mut self.rng)
    }

    fn on_sample_bool(&amp;mut self, addr: &amp;Address, dist: &amp;dyn Distribution&lt;bool&gt;) -&gt; bool {
        // Handle Bernoulli - returns bool directly!
        dist.sample(&amp;mut self.rng)
    }

    fn on_sample_u64(&amp;mut self, addr: &amp;Address, dist: &amp;dyn Distribution&lt;u64&gt;) -&gt; u64 {
        // Handle Poisson/Binomial - returns counts as u64
        dist.sample(&amp;mut self.rng)
    }

    fn on_sample_usize(&amp;mut self, addr: &amp;Address, dist: &amp;dyn Distribution&lt;usize&gt;) -&gt; usize {
        // Handle Categorical - returns indices as usize
        dist.sample(&amp;mut self.rng)
    }

    fn on_observe_f64(&amp;mut self, addr: &amp;Address, dist: &amp;dyn Distribution&lt;f64&gt;, value: f64) {
        // Observe continuous values
    }

    fn on_observe_bool(&amp;mut self, addr: &amp;Address, dist: &amp;dyn Distribution&lt;bool&gt;, value: bool) {
        // Observe boolean outcomes
    }

    fn on_observe_u64(&amp;mut self, addr: &amp;Address, dist: &amp;dyn Distribution&lt;u64&gt;, value: u64) {
        // Observe u64 values
    }

    fn on_observe_usize(&amp;mut self, addr: &amp;Address, dist: &amp;dyn Distribution&lt;usize&gt;, value: usize) {
        // Observe usize values  
    }

    fn on_factor(&amp;mut self, logw: f64) {
        // Handle factors
    }

    fn finish(self) -&gt; Trace {
        Trace::default()
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="hierarchical-addressing"><a class="header" href="#hierarchical-addressing">Hierarchical Addressing</a></h3>
<p>Organize complex models with scoped addresses:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use fugue::*;
</span>let hierarchical = prob! {
    let global_params &lt;- plate!(layer in 0..3 =&gt; {
        sample(scoped_addr!("layer", layer, "weight"), Normal::new(0.0, 1.0).unwrap())
    });
    // ... rest of model
    pure(global_params)
};
<span class="boring">}</span></code></pre></pre>
<h3 id="memory-efficient-trace-manipulation"><a class="header" href="#memory-efficient-trace-manipulation">Memory-Efficient Trace Manipulation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use fugue::*;
</span>// Efficient trace operations with type-safe values
let mut trace = Trace::default();
trace.insert_choice(addr!("x"), ChoiceValue::F64(1.5), 0.0);       // Continuous
trace.insert_choice(addr!("coin"), ChoiceValue::Bool(true), -0.5);  // Boolean
trace.insert_choice(addr!("count"), ChoiceValue::U64(7), -2.1);     // Count
trace.insert_choice(addr!("choice"), ChoiceValue::Usize(2), -1.6);  // Index

// Trace validation and debugging
println!("Total log weight: {:.4}", trace.total_log_weight());
<span class="boring">}</span></code></pre></pre>
<h2 id="-validation--testing"><a class="header" href="#-validation--testing">🧪 Validation &amp; Testing</a></h2>
<p>Fugue includes extensive validation against analytical solutions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use fugue::*;
</span><span class="boring">use rand::rngs::StdRng;
</span><span class="boring">use rand::SeedableRng;
</span><span class="boring">use fugue::inference::validation::ConjugateNormalConfig;
</span><span class="boring">let mut rng = StdRng::seed_from_u64(42);
</span><span class="boring">let config = ConjugateNormalConfig {
</span><span class="boring">    prior_mu: 0.0,
</span><span class="boring">    prior_sigma: 1.0,
</span><span class="boring">    likelihood_sigma: 0.5,
</span><span class="boring">    observation: 2.0,
</span><span class="boring">    n_samples: 1000,
</span><span class="boring">    n_warmup: 500,
</span><span class="boring">};
</span>// Validate MCMC against known posterior  
let prior_mu = config.prior_mu;
let prior_sigma = config.prior_sigma;
let likelihood_sigma = config.likelihood_sigma;
let observation = config.observation;

let validation = test_conjugate_normal_model(
    &amp;mut rng,
    move |rng, n_samples, n_warmup| {
        adaptive_mcmc_chain(rng, move || {
            sample(addr!("mu"), Normal::new(prior_mu, prior_sigma).unwrap())
                .bind(move |mu| {
                    observe(addr!("y"), Normal::new(mu, likelihood_sigma).unwrap(), observation);
                    pure(mu)
                })
        }, n_samples, n_warmup)
    },
    config,
);

println!("Validation complete: {}", validation.is_valid());
<span class="boring">}</span></code></pre></pre>
<h2 id="-performance"><a class="header" href="#-performance">⚡ Performance</a></h2>
<p>Fugue is designed for production workloads:</p>
<ul>
<li><strong>Zero-cost abstractions</strong>: Monadic composition compiles to efficient code</li>
<li><strong>Memory optimization</strong>: Efficient trace representation and garbage collection</li>
<li><strong>Numerical stability</strong>: IEEE 754-compliant log-probability arithmetic</li>
<li><strong>Scalable inference</strong>: Support for large models with thousands of parameters</li>
</ul>
<p>Benchmark on your hardware:</p>
<pre><code class="language-bash">cargo bench
</code></pre>
<h2 id="-contributing"><a class="header" href="#-contributing">🤝 Contributing</a></h2>
<p>We welcome contributions! Please see our <a href=".github/CONTRIBUTING.html">Contributing Guidelines</a> for details.</p>
<h3 id="development-setup"><a class="header" href="#development-setup">Development Setup</a></h3>
<pre><code class="language-bash">git clone https://github.com/alexandernodeland/fugue.git
cd fugue
cargo test
cargo test --doc
cargo run --example gaussian_mean
</code></pre>
<h3 id="running-tests"><a class="header" href="#running-tests">Running Tests</a></h3>
<pre><code class="language-bash"># Unit tests
cargo test

# Integration tests
cargo test --test '*'

# Property-based tests
cargo test property_tests

# Documentation tests
cargo test --doc
</code></pre>
<h2 id="-documentation"><a class="header" href="#-documentation">📖 Documentation</a></h2>
<h3 id="-getting-started"><a class="header" href="#-getting-started">🚀 Getting Started</a></h3>
<ul>
<li><strong><a href="docs/src/getting-started/installation.html">⚡ Installation Guide</a></strong> - Get up and running quickly</li>
<li><strong><a href="docs/src/getting-started/your-first-model.html">🎯 Your First Model</a></strong> - Build your first probabilistic model</li>
</ul>
<h3 id="-learning-resources"><a class="header" href="#-learning-resources">📚 Learning Resources</a></h3>
<ul>
<li>
<p><strong><a href="docs/src/tutorials/README.html">🎓 Tutorials</a></strong> - Step-by-step learning:</p>
<ul>
<li><strong>Foundation Tutorials</strong>:
<ul>
<li><a href="docs/src/tutorials/foundation/bayesian-coin-flip.html">Bayesian Coin Flip</a> (Beginner)</li>
<li><a href="docs/src/tutorials/foundation/type-safety-features.html">Type Safety Features</a> (Beginner)</li>
<li><a href="docs/src/tutorials/foundation/trace-manipulation.html">Trace Manipulation</a> (Beginner)</li>
</ul>
</li>
<li><strong>Statistical Modeling</strong>:
<ul>
<li><a href="docs/src/tutorials/statistical-modeling/linear-regression.html">Linear Regression</a> (Intermediate)</li>
<li><a href="docs/src/tutorials/statistical-modeling/classification.html">Classification</a> (Intermediate)</li>
<li><a href="docs/src/tutorials/statistical-modeling/mixture-models.html">Mixture Models</a> (Intermediate)</li>
<li><a href="docs/src/tutorials/statistical-modeling/hierarchical-models.html">Hierarchical Models</a> (Advanced)</li>
</ul>
</li>
<li><strong>Advanced Applications</strong>:
<ul>
<li><a href="docs/src/tutorials/advanced-applications/time-series-forecasting.html">Time Series &amp; Forecasting</a> (Advanced)</li>
<li><a href="docs/src/tutorials/advanced-applications/model-comparison-selection.html">Model Comparison &amp; Selection</a> (Advanced)</li>
<li><a href="docs/src/tutorials/advanced-applications/advanced-inference.html">Advanced Inference</a> (Advanced)</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong><a href="docs/src/how-to/README.html">🛠️ How-To Guides</a></strong> - Practical solutions:</p>
<ul>
<li><a href="docs/src/how-to/working-with-distributions.html">Working with Distributions</a></li>
<li><a href="docs/src/how-to/building-complex-models.html">Building Complex Models</a></li>
<li><a href="docs/src/how-to/optimizing-performance.html">Optimizing Performance</a></li>
<li><a href="docs/src/how-to/debugging-models.html">Debugging Models</a></li>
<li><a href="docs/src/how-to/custom-handlers.html">Custom Handlers</a></li>
<li><a href="docs/src/how-to/production-deployment.html">Production Deployment</a></li>
</ul>
</li>
</ul>
<h3 id="-reference"><a class="header" href="#-reference">📖 Reference</a></h3>
<ul>
<li><strong><a href="https://docs.rs/fugue">API Documentation</a></strong> - Complete API reference</li>
<li><strong><a href="examples/">Examples</a></strong> - Practical usage examples</li>
</ul>
<h2 id="-license"><a class="header" href="#-license">📄 License</a></h2>
<p>Licensed under either of</p>
<ul>
<li>Apache License, Version 2.0 (<a href="LICENSE-APACHE">LICENSE-APACHE</a> or <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>)</li>
<li>MIT license (<a href="LICENSE-MIT">LICENSE-MIT</a> or <a href="http://opensource.org/licenses/MIT">http://opensource.org/licenses/MIT</a>)</li>
</ul>
<p>at your option.</p>
<h2 id="-contributing-1"><a class="header" href="#-contributing-1">📄 Contributing</a></h2>
<p>Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you shall be dual licensed as above, without any additional terms or conditions.</p>
<h2 id="-acknowledgments"><a class="header" href="#-acknowledgments">🙏 Acknowledgments</a></h2>
<p>Fugue draws inspiration from:</p>
<ul>
<li><strong><a href="https://github.com/probcomp/Gen.jl">Gen.jl</a></strong> - General-purpose probabilistic programming in Julia</li>
<li><strong><a href="https://webppl.org/">WebPPL</a></strong> - Functional probabilistic programming</li>
</ul>
<h2 id="-citation"><a class="header" href="#-citation">🔗 Citation</a></h2>
<p>If you use Fugue in your research, please cite:</p>
<pre><code class="language-bibtex">@software{fugue2024,
  title = {Fugue: Production-Ready Monadic Probabilistic Programming for Rust},
  author = {Alexander Nodeland},
  url = {https://github.com/alexandernodeland/fugue},
  version = {0.3.0},
  year = {2024}
}
</code></pre>
<hr />
<p><strong>Built with ❤️ in Rust</strong> | <a href="https://github.com/alexandernodeland/fugue">Website</a> | <a href="https://docs.rs/fugue">Documentation</a> | <a href="https://crates.io/crates/fugue">Crates.io</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->

                            <a rel="next prefetch" href="getting-started/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

                    <a rel="next prefetch" href="getting-started/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>



    </div>
    </body>
</html>
